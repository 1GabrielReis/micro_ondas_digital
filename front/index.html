<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Micro-ondas Digital</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Basic Styles for elements not easily handled by Tailwind */
        body {
            font-family: 'Inter', sans-serif;
        }

        .microwave-panel {
            background: linear-gradient(145deg, #e6e6e6, #ffffff);
            border: 1px solid #d1d1d1;
        }

        .microwave-door {
            background-color: #333;
            border: 5px solid #222;
        }

        .microwave-window {
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .display {
            font-family: 'Courier New', Courier, monospace;
            background-color: #0c1a0c;
            color: #32cd32;
            text-shadow: 0 0 5px #32cd32, 0 0 10px #32cd32;
            border: 2px solid #222;
        }

        #heatingProgress {
            font-family: 'Courier New', Courier, monospace;
            color: #ff8c00;
            text-shadow: 0 0 3px #ff8c00;
            padding: 0 1rem;
            text-align: center;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            word-break: break-all;
        }

        .door-handle {
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 40%;
            background-color: #222;
            border-radius: 0 5px 5px 0;
            border-left: 1px solid #444;
        }

        .controls-panel {
            background-color: #f3f4f6;
        }

        .input-field {
            background-color: #e5e7eb;
            border: 1px solid #d1d5db;
            transition: all 0.2s ease-in-out;
        }

        .input-field:focus {
            background-color: #fff;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }
        
        .input-field:disabled {
            background-color: #f3f4f6;
            cursor: not-allowed;
        }

        .keypad-btn,
        .action-btn,
        .program-btn {
            border: 1px solid #ccc;
            background-color: #e5e7eb;
            transition: all 0.1s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .keypad-btn:active,
        .action-btn:active,
        .program-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .start-btn {
            background-color: #22c55e;
            color: white;
        }

        .start-btn:hover {
            background-color: #16a34a;
        }

        .cancel-btn {
            background-color: #ef4444;
            color: white;
        }

        .cancel-btn:hover {
            background-color: #dc2626;
        }

        .program-btn {
            background-color: #d1d5db;
            cursor: pointer;
        }

        .program-btn:hover {
            background-color: #9ca3af;
            color: white;
        }

        .program-btn.active {
            background-color: #3b82f6;
            color: white;
            border-color: #2563eb;
            font-weight: 600;
        }

        .italic-program {
            font-style: italic;
        }

        /* Message Box Styling */
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 90%;
        }

        .message-box.success {
            background-color: #22c55e;
        }

        .message-box.error {
            background-color: #ef4444;
        }

        .message-box.info {
            background-color: #3b82f6;
        }
    </style>
</head>

<body class="flex items-center justify-center min-h-screen bg-gray-200 p-4">
    <div id="messageBox" class="message-box"></div>

    <div class="microwave-panel w-full max-w-3xl p-3 sm:p-5 rounded-lg shadow-2xl">
        <div class="flex flex-col lg:flex-row gap-3 sm:gap-5">
            <div class="microwave-door flex-grow lg:w-3/5 p-3 sm:p-4 rounded-md relative">
                <div class="microwave-window w-full h-48 sm:h-64 rounded p-2">
                    <div id="display"
                        class="display text-4xl sm:text-5xl font-bold p-3 sm:p-4 rounded-md w-full text-center select-none">
                        00:00</div>
                    <div id="heatingProgress" class="select-none"></div>
                </div>
                <div class="door-handle"></div>
            </div>

            <div class="controls-panel lg:w-2/5 bg-gray-100 p-3 sm:p-4 rounded-md shadow-inner flex flex-col">
                <div class="mb-3">
                    <div class="grid grid-cols-2 gap-2 mb-2">
                        <div>
                            <label for="timeInput" class="block text-xs font-medium text-gray-700 mb-1">Tempo
                                (MM:SS):</label>
                            <input type="text" id="timeInput"
                                class="input-field w-full p-2 rounded-md text-center text-sm" placeholder="00:00"
                                maxlength="5">
                        </div>
                        <div>
                            <label for="powerInput" class="block text-xs font-medium text-gray-700 mb-1">Potência
                                (1-10):</label>
                            <input type="number" id="powerInput"
                                class="input-field w-full p-2 rounded-md text-center text-sm" min="1" max="10"
                                placeholder="10">
                        </div>
                    </div>
                </div>

                <div class="mb-3">
                    <div class="grid grid-cols-3 gap-1 sm:gap-2">
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base" data-value="1">1</button>
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base" data-value="2">2</button>
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base" data-value="3">3</button>
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base" data-value="4">4</button>
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base" data-value="5">5</button>
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base" data-value="6">6</button>
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base" data-value="7">7</button>
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base" data-value="8">8</button>
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base" data-value="9">9</button>
                        <button class="keypad-btn p-2 sm:p-3 rounded text-sm sm:text-base col-start-2"
                            data-value="0">0</button>
                    </div>
                </div>

                <div class="grid grid-cols-1 gap-2 mb-3">
                    <button id="startBtn"
                        class="action-btn start-btn p-3 rounded font-semibold text-sm sm:text-base">Iniciar /
                        +30s</button>
                    <button id="pauseCancelBtn"
                        class="action-btn cancel-btn p-3 rounded font-semibold text-sm sm:text-base">Pausar /
                        Cancelar</button>
                </div>

                <div class="mb-3">
                    <h3 class="text-sm font-semibold text-gray-700 mb-1">Programas Pré-definidos:</h3>
                    <div id="predefinedProgramsContainer" class="grid grid-cols-2 sm:grid-cols-3 gap-1 text-xs">
                    </div>
                </div>

                <div class="mt-auto">
                    <h3 class="text-sm font-semibold text-gray-700 mb-1">Programas Customizados (<span
                            id="customProgramCount">0</span>/5):</h3>
                    <div id="customProgramsContainer" class="grid grid-cols-2 sm:grid-cols-3 gap-1 text-xs">
                    </div>
                    <button id="addCustomProgramBtn"
                        class="action-btn w-full mt-2 p-2 rounded text-xs bg-blue-500 text-white hover:bg-blue-600">Adicionar
                        Programa</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for adding/editing programs -->
    <div id="customProgramModal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center"
        style="display: none;">
        <div class="relative mx-auto p-5 border w-full max-w-md shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900" id="modalTitle">Adicionar Programa Customizado
                </h3>
                <div class="mt-2 px-7 py-3">
                    <input type="hidden" id="editingProgramId" value="">
                    <label for="programName" class="block text-sm font-medium text-gray-700 text-left">Nome do
                        Programa:</label>
                    <input type="text" id="programName" class="input-field w-full p-2 mt-1 mb-3 rounded-md text-sm"
                        required>

                    <label for="programFood" class="block text-sm font-medium text-gray-700 text-left">Alimento:</label>
                    <input type="text" id="programFood" class="input-field w-full p-2 mt-1 mb-3 rounded-md text-sm"
                        required>

                    <div class="grid grid-cols-2 gap-2 mb-3">
                        <div>
                            <label for="programTime" class="block text-sm font-medium text-gray-700 text-left">Tempo
                                (MM:SS):</label>
                            <input type="text" id="programTime" class="input-field w-full p-2 mt-1 rounded-md text-sm"
                                placeholder="00:00" required>
                        </div>
                        <div>
                            <label for="programPower" class="block text-xs font-medium text-gray-700 text-left">Potência
                                (1-10):</label>
                            <input type="number" id="programPower"
                                class="input-field w-full p-2 mt-1 rounded-md text-sm" min="1" max="10" placeholder="10"
                                required>
                        </div>
                    </div>

                    <label for="programInstructions"
                        class="block text-sm font-medium text-gray-700 text-left">Instruções (Opcional):</label>
                    <textarea id="programInstructions" class="input-field w-full p-2 mt-1 mb-3 rounded-md text-sm"
                        rows="3" maxlength="255"></textarea>
                </div>
                <div class="items-center px-4 py-3 space-x-2">
                    <button id="saveProgramBtn"
                        class="modal-btn px-4 py-2 bg-green-500 text-white text-base font-medium rounded-md w-auto shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-300">
                        Salvar
                    </button>
                    <button id="deleteProgramBtn"
                        class="modal-btn px-4 py-2 bg-red-500 text-white text-base font-medium rounded-md w-auto shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-300"
                        style="display:none;">
                        Excluir
                    </button>
                    <button id="cancelModalBtn"
                        class="modal-btn px-4 py-2 bg-gray-300 text-gray-700 text-base font-medium rounded-md w-auto shadow-sm hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-300">
                        Cancelar
                    </button>
                </div>
            </div>
        </div>
    </div>


    <script>
        // --- Element References ---
        const displayElement = document.getElementById('display');
        const timeInput = document.getElementById('timeInput');
        const powerInput = document.getElementById('powerInput');
        const heatingProgressDisplay = document.getElementById('heatingProgress');
        const startBtn = document.getElementById('startBtn');
        const pauseCancelBtn = document.getElementById('pauseCancelBtn');
        const keypadBtns = document.querySelectorAll('.keypad-btn');
        const messageBox = document.getElementById('messageBox');
        const predefinedProgramsContainer = document.getElementById('predefinedProgramsContainer');
        const customProgramsContainer = document.getElementById('customProgramsContainer');
        const addCustomProgramBtn = document.getElementById('addCustomProgramBtn');
        const customProgramModal = document.getElementById('customProgramModal');
        const modalTitle = document.getElementById('modalTitle');
        const saveProgramBtn = document.getElementById('saveProgramBtn');
        const cancelModalBtn = document.getElementById('cancelModalBtn');
        const deleteProgramBtn = document.getElementById('deleteProgramBtn');
        const programNameInput = document.getElementById('programName');
        const programFoodInput = document.getElementById('programFood');
        const programTimeInput = document.getElementById('programTime');
        const programPowerInput = document.getElementById('programPower');
        const programInstructionsInput = document.getElementById('programInstructions');
        const editingProgramIdInput = document.getElementById('editingProgramId');
        const customProgramCountDisplay = document.getElementById('customProgramCount');

        // --- Microwave State ---
        let totalSeconds = 0;
        let currentPower = 10;
        let heatingInterval = null;
        let paused = false;
        const FIXED_HEATING_CHAR = '.';
        let activeProgram = null;
        let accumulatedDotsString = "";
        const MAX_DISPLAYED_DOT_CHARS = 60;

        // --- Program Constants ---
        const MAX_CUSTOM_PROGRAMS = 5;
        const INSTRUCTIONS_TITLE_MAX_LENGTH = 30;
        const DEFAULT_HEATING_PROGRESS_FONT_SIZE = "1.75rem";
        const MIN_INSTRUCTION_FONT_SIZE_REM = 0.6;

        // --- State Variables ---
        let currentProgramBeingViewed = null;
        let clickTimer = null;
        const DOUBLE_CLICK_DELAY = 300;
        
        // --- Sound Synthesis with Tone.js ---
        let soundsInitialized = false;
        let beepSound;

        // --- API Configuration ---
        const API_BASE_URL = "http://localhost:5091/api/MicroondasControllers";

        // --- Program Data Arrays ---
        let PREDEFINED_PROGRAMS = [];
        let customPrograms = [];

        // --- Initialization ---
        async function initializeSounds() {
            if (soundsInitialized) return;
            try {
                await Tone.start();
                beepSound = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.05 }
                }).toDestination();
                soundsInitialized = true;
                console.log("Beep sound initialized by Tone.js");
            } catch (error) {
                console.error("Error initializing sounds:", error);
            }
        }

        function playBeep() {
            if (!soundsInitialized || !beepSound) return;
            try {
                beepSound.triggerAttackRelease("C5", "8n");
            } catch (error) {
                console.error("Error playing beep sound:", error);
            }
        }

        document.body.addEventListener('click', initializeSounds, { once: true });
        document.body.addEventListener('touchstart', initializeSounds, { once: true });

        // --- API Functions ---
        async function fetchProgramsFromAPI() {
    try {
        const response = await fetch(API_BASE_URL);

        if (!response.ok) {
            throw new Error(`Erro na resposta da API: ${response.status}`);
        }

        const responseData = await response.json();
        console.log("✅ Resposta da API:", responseData);

        const allProgramsFromAPI = responseData.data;

        if (!Array.isArray(allProgramsFromAPI)) {
            console.error("❌ 'data' não é um array:", allProgramsFromAPI);
            throw new Error("A propriedade 'data' não é um array.");
        }

        PREDEFINED_PROGRAMS = allProgramsFromAPI
            .filter(p => p.preDefinido === true)
            .map(p => ({
                id: p.id,
                name: p.nomePrograma,
                food: p.alimento,
                time: parseInt(p.tempo, 10) || 0,
                power: parseInt(p.potencia, 10) || 10,
                char: p.charPonto || FIXED_HEATING_CHAR,
                instructions: p.instrucoes,
                isCustom: false,
                preDefinido: true
            }));

        customPrograms = allProgramsFromAPI
            .filter(p => p.preDefinido === false)
            .map(p => ({
                id: p.id,
                name: p.nomePrograma,
                food: p.alimento,
                time: parseInt(p.tempo, 10) || 0,
                power: parseInt(p.potencia, 10) || 10,
                char: p.charPonto || FIXED_HEATING_CHAR,
                instructions: p.instrucoes,
                isCustom: true,
                preDefinido: false
            }));

        renderPrograms();
        updateCustomProgramCount();

    } catch (error) {
        console.error("💥 Erro ao buscar programas:", error);
        let userErrorMessage = `Erro ao carregar programas. Verifique o console para detalhes.`;
        if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
            userErrorMessage = "Não foi possível conectar à API. Verifique se ela está rodando.";
        }
        showMessage(userErrorMessage, "error", 10000);
    }
}

        // --- UI Helper Functions ---
        function showMessage(text, type = 'error', duration = 3000) {
            messageBox.textContent = text;
            messageBox.className = 'message-box';
            messageBox.classList.remove('success', 'info', 'error');
            messageBox.classList.add(type);
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }

        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) seconds = 0;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function updateDisplay() {
            displayElement.textContent = formatTime(totalSeconds);
        }

        function truncateText(text, maxLength) {
            if (!text) return '';
            return text.length <= maxLength ? text : text.substring(0, maxLength) + "...";
        }

        function resetHeatingProgressStyle() {
            heatingProgressDisplay.style.fontSize = DEFAULT_HEATING_PROGRESS_FONT_SIZE;
            heatingProgressDisplay.style.lineHeight = "1.2";
        }

        function adjustFontSizeToFit(element, text) {
            element.textContent = text;
            let currentFontSize = 1.0;
            element.style.fontSize = `${currentFontSize}rem`;
            const parentHeight = element.parentElement.clientHeight;
            const maxHeight = parentHeight > 0 ? parentHeight * 0.8 : 0;
            if (maxHeight <= 0) return;
            while (element.scrollHeight > maxHeight && currentFontSize > MIN_INSTRUCTION_FONT_SIZE_REM) {
                currentFontSize -= 0.05;
                element.style.fontSize = `${currentFontSize}rem`;
            }
        }

        // --- Microwave Operation Functions ---
        function clearAll() {
            clearInterval(heatingInterval);
            heatingInterval = null;
            totalSeconds = 0;
            currentPower = 10;
            paused = false;
            activeProgram = null;
            currentProgramBeingViewed = null;
            accumulatedDotsString = "";
            timeInput.value = '';
            powerInput.value = '10';
            heatingProgressDisplay.textContent = '';
            resetHeatingProgressStyle();
            updateDisplay();
            enableInputs();
            deselectProgramButtons();
        }

        function disableInputs(isHeating = false) {
            timeInput.disabled = true;
            powerInput.disabled = true;
            keypadBtns.forEach(btn => btn.disabled = isHeating);
            addCustomProgramBtn.disabled = true;
            document.querySelectorAll('.program-btn, .custom-program-btn').forEach(btn => btn.disabled = isHeating);
        }

        function enableInputs() {
            timeInput.disabled = false;
            powerInput.disabled = false;
            keypadBtns.forEach(btn => btn.disabled = false);
            addCustomProgramBtn.disabled = customPrograms.length >= MAX_CUSTOM_PROGRAMS;
            document.querySelectorAll('.program-btn, .custom-program-btn').forEach(btn => btn.disabled = false);
        }

        let focusedInput = timeInput;
        timeInput.addEventListener('focus', () => focusedInput = timeInput);
        powerInput.addEventListener('focus', () => focusedInput = powerInput);

        timeInput.addEventListener('input', (e) => {
            let value = e.target.value.replace(/\D/g, '');
            if (value.length > 4) value = value.substring(0, 4);
            if (value.length > 2) {
                value = value.substring(0, 2) + ':' + value.substring(2);
            }
            e.target.value = value;
        });

        keypadBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                playBeep();
                if (heatingInterval && !paused) return;
                if (activeProgram && heatingInterval) return;

                const digitValue = btn.dataset.value;
                if (focusedInput === timeInput) {
                    let currentTimeString = timeInput.value.replace(':', '');
                    if (currentTimeString.length < 4) {
                        currentTimeString += digitValue;
                        timeInput.value = currentTimeString.length > 2 ?
                            currentTimeString.substring(0, 2) + ':' + currentTimeString.substring(2, 4) :
                            currentTimeString;
                    }
                } else if (focusedInput === powerInput) {
                    let currentPowerString = powerInput.value;
                    if (digitValue === "0" && currentPowerString === "1") {
                        powerInput.value = "10";
                    } else if (digitValue !== "0" && currentPowerString === "") {
                        powerInput.value = digitValue;
                    }
                }
            });
        });

        function startHeatingSequence() {
            if (heatingInterval && !paused) {
                if (activeProgram && activeProgram.preDefinido === true) {
                    showMessage("Não é permitido adicionar tempo para programas pré-definidos.", "info");
                    return;
                }
                totalSeconds += 30;
                if (!activeProgram && totalSeconds > 120) totalSeconds = 120;
                updateDisplay();
                showMessage("+30 segundos adicionados!", "success");
                return;
            }

            if (!activeProgram) {
                const timeStr = timeInput.value;
                const powerVal = parseInt(powerInput.value, 10);
                if (!timeStr.trim() && (!powerInput.value.trim() || powerInput.value.trim() === '10')) {
                    totalSeconds = 30;
                    currentPower = 10;
                    powerInput.value = '10';
                    timeInput.value = formatTime(30);
                    showMessage("Início Rápido: 30s, Potência 10", "info");
                } else {
                    const parts = timeStr.split(':');
                    const minutes = parseInt(parts[0], 10) || 0;
                    const seconds = parseInt(parts[1], 10) || 0;
                    totalSeconds = (minutes * 60) + seconds;

                    if (isNaN(powerVal) || powerInput.value.trim() === '') {
                        currentPower = 10;
                        powerInput.value = '10';
                    } else if (powerVal < 1 || powerVal > 10) {
                        showMessage("Potência inválida. Use valores entre 1 e 10.", "error");
                        return;
                    } else {
                        currentPower = powerVal;
                    }
                    if (totalSeconds < 1 || totalSeconds > 120) {
                        showMessage("Tempo inválido para entrada manual. Use valores entre 00:01 e 02:00.", "error");
                        return;
                    }
                }
            } else {
                totalSeconds = activeProgram.time;
                currentPower = activeProgram.power;
            }

            updateDisplay();
            paused = false;
            disableInputs(true);
            resetHeatingProgressStyle();
            heatingProgressDisplay.textContent = '';
            accumulatedDotsString = "";

            heatingInterval = setInterval(() => {
                if (paused) return;

                totalSeconds--;
                updateDisplay();

                const heatingCharToUse = activeProgram?.char || FIXED_HEATING_CHAR;
                if (totalSeconds >= 0) {
                    const currentDotChunk = heatingCharToUse.repeat(currentPower);
                    if (accumulatedDotsString.length + currentDotChunk.length + 1 > MAX_DISPLAYED_DOT_CHARS) {
                        accumulatedDotsString = currentDotChunk.substring(0, MAX_DISPLAYED_DOT_CHARS);
                    } else {
                        accumulatedDotsString = accumulatedDotsString ? `${accumulatedDotsString} ${currentDotChunk}` : currentDotChunk;
                    }
                    heatingProgressDisplay.textContent = accumulatedDotsString;
                } else {
                    clearInterval(heatingInterval);
                    heatingInterval = null;
                    heatingProgressDisplay.textContent = "FIM";
                    showMessage("Aquecimento concluído!", "success");
                    enableInputs();
                    deselectProgramButtons();
                    activeProgram = null;
                }
            }, 1000);
        }

        function pauseResumeHeating() {
            playBeep();
            if (heatingInterval && !paused) {
                paused = true;
                showMessage("Aquecimento pausado.", "info");
                return;
            }
            if (paused) {
                clearInterval(heatingInterval);
                heatingInterval = null;
                paused = false;
                showMessage("Aquecimento cancelado.", "info");
                clearAll();
                return;
            }
            if (!heatingInterval && !paused) {
                if (timeInput.value || powerInput.value !== '10' || activeProgram) {
                    showMessage("Entradas limpas / Seleção cancelada.", "info");
                    clearAll();
                }
            }
        }

        startBtn.addEventListener('click', () => {
            playBeep();
            if (paused) {
                paused = false;
                showMessage("Aquecimento retomado.", "info");
                disableInputs(true);
            } else {
                startHeatingSequence();
            }
        });
        pauseCancelBtn.addEventListener('click', pauseResumeHeating);

        // --- Program Rendering and Management ---
        function deselectProgramButtons() {
            document.querySelectorAll('.program-btn.active').forEach(btn => {
                btn.classList.remove('active', 'bg-blue-600', 'text-white', 'border-blue-700');
            });
        }

        function selectProgram(program) {
            playBeep();
            if (heatingInterval) {
                showMessage("Não é possível selecionar programa durante o aquecimento.", "info");
                return;
            }
            clearAll();
            activeProgram = program;
            totalSeconds = program.time;
            powerInput.value = program.power;
            timeInput.value = formatTime(program.time);
            updateDisplay();

            if (program.instructions) {
                adjustFontSizeToFit(heatingProgressDisplay, program.instructions);
            }

            timeInput.disabled = true;
            powerInput.disabled = true;
            keypadBtns.forEach(btn => btn.disabled = true);

            deselectProgramButtons();
            const buttonId = `${program.isCustom ? 'custom' : 'predefined'}-prog-${program.id}`;
            const selectedBtn = document.getElementById(buttonId);
            if (selectedBtn) {
                selectedBtn.classList.add('active', 'bg-blue-600', 'text-white', 'border-blue-700');
            }
        }

        function updateCustomProgramCount() {
            customProgramCountDisplay.textContent = customPrograms.length;
            addCustomProgramBtn.disabled = customPrograms.length >= MAX_CUSTOM_PROGRAMS;
        }

        function renderPrograms() {
            predefinedProgramsContainer.innerHTML = '';
            PREDEFINED_PROGRAMS.forEach(prog => {
                const btn = document.createElement('button');
                btn.id = `predefined-prog-${prog.id}`;
                btn.className = 'program-btn p-1.5 rounded text-center truncate text-xs sm:text-sm';
                btn.textContent = prog.name;
                btn.title = `Alimento: ${prog.food}\nTempo: ${formatTime(prog.time)}\nPotência: ${prog.power}\nInstruções: ${prog.instructions || 'Nenhuma'}`;
                btn.addEventListener('click', (e) => handleProgramClick(e, prog));
                predefinedProgramsContainer.appendChild(btn);
            });

            customProgramsContainer.innerHTML = '';
            customPrograms.forEach(prog => {
                const btn = document.createElement('button');
                btn.id = `custom-prog-${prog.id}`;
                btn.className = 'custom-program-btn program-btn p-1.5 rounded text-center truncate italic-program text-xs sm:text-sm';
                btn.textContent = prog.name;
                btn.title = `Alimento: ${prog.food}\nTempo: ${formatTime(prog.time)}\nPotência: ${prog.power}\nInstruções: ${prog.instructions || 'Nenhuma'}`;
                btn.addEventListener('click', (e) => handleProgramClick(e, prog));
                customProgramsContainer.appendChild(btn);
            });
            updateCustomProgramCount();
        }

        function handleProgramClick(event, program) {
            let clickCount = parseInt(event.currentTarget.dataset.clickCount || '0', 10);
            clickCount++;
            event.currentTarget.dataset.clickCount = clickCount;

            if (clickCount === 1) {
                clickTimer = setTimeout(() => {
                    if (heatingInterval && !paused) return;
                    selectProgram(program);
                    event.currentTarget.dataset.clickCount = 0;
                }, DOUBLE_CLICK_DELAY);
            } else if (clickCount === 2) {
                clearTimeout(clickTimer);
                if (heatingInterval && !paused) return;
                openCustomProgramModal(program);
                event.currentTarget.dataset.clickCount = 0;
            }
        }

        // --- Modal Functions ---
        function setModalInputsState(disabled) {
            programNameInput.disabled = disabled;
            programFoodInput.disabled = disabled;
            programTimeInput.disabled = disabled;
            programPowerInput.disabled = disabled;
            programInstructionsInput.disabled = disabled;
        }
        
        function openCustomProgramModal(programToHandle = null) {
            playBeep();
            currentProgramBeingViewed = programToHandle;

            if (!programToHandle) { // Adding new program
                if (customPrograms.length >= MAX_CUSTOM_PROGRAMS) {
                    showMessage(`Limite de ${MAX_CUSTOM_PROGRAMS} programas customizados atingido.`, "info");
                    return;
                }
                modalTitle.textContent = "Adicionar Programa Customizado";
                setModalInputsState(false);
                editingProgramIdInput.value = "";
                programNameInput.value = '';
                programFoodInput.value = '';
                programTimeInput.value = '';
                programPowerInput.value = '10';
                programInstructionsInput.value = '';
                deleteProgramBtn.style.display = 'none';
                saveProgramBtn.style.display = 'inline-block';
                saveProgramBtn.textContent = "Salvar Novo";
            } else { // Viewing or Editing an existing program
                editingProgramIdInput.value = programToHandle.id;
                programNameInput.value = programToHandle.name;
                programFoodInput.value = programToHandle.food;
                programTimeInput.value = formatTime(programToHandle.time);
                programPowerInput.value = programToHandle.power;
                programInstructionsInput.value = programToHandle.instructions || '';

                setModalInputsState(false); // Always enable inputs visually
                saveProgramBtn.style.display = 'inline-block'; // Always show save button

                if (programToHandle.isCustom) {
                    modalTitle.textContent = "Editar Programa Customizado";
                    saveProgramBtn.textContent = "Salvar Alterações";
                    deleteProgramBtn.style.display = 'inline-block';
                } else {
                    modalTitle.textContent = "Editar Programa Pré-definido";
                    saveProgramBtn.textContent = "Salvar Alterações";
                    deleteProgramBtn.style.display = 'none'; // Hide delete for predefined
                }
            }
            customProgramModal.style.display = 'flex';
        }

        function closeCustomProgramModal() {
            playBeep();
            customProgramModal.style.display = 'none';
            currentProgramBeingViewed = null;
        }

        addCustomProgramBtn.addEventListener('click', () => openCustomProgramModal(null));
        cancelModalBtn.addEventListener('click', closeCustomProgramModal);

        // --- SAVE Program (Handles POST and PUT for custom programs) ---
        saveProgramBtn.addEventListener('click', async () => {
            playBeep();
            
            // NEW: Check if trying to save a predefined program
            if (currentProgramBeingViewed && !currentProgramBeingViewed.isCustom) {
                showMessage("Não é possível editar um programa pré-definido.", "error");
                return;
            }

            const name = programNameInput.value.trim();
            const food = programFoodInput.value.trim();
            const timeStr = programTimeInput.value;
            const power = parseInt(programPowerInput.value, 10);
            const instructions = programInstructionsInput.value.trim();
            const editingId = editingProgramIdInput.value;

            if (!name || !food || !timeStr || isNaN(power)) {
                showMessage("Preencha todos os campos obrigatórios.", "error");
                return;
            }

            const timeParts = timeStr.split(':');
            const totalProgSeconds = (parseInt(timeParts[0], 10) || 0) * 60 + (parseInt(timeParts[1], 10) || 0);
            if (totalProgSeconds <= 0 || power < 1 || power > 10) {
                showMessage("Valores de tempo ou potência inválidos.", "error");
                return;
            }

            const nameLower = name.toLowerCase();
            const conflictingProgram = [...PREDEFINED_PROGRAMS, ...customPrograms].find(p => p.name.toLowerCase() === nameLower && p.id != editingId);
            if (conflictingProgram) {
                showMessage(`O nome "${name}" já está em uso.`, "error");
                return;
            }

            const isEditing = !!editingId;

            if (!isEditing && customPrograms.length >= MAX_CUSTOM_PROGRAMS) {
                showMessage("Limite de programas customizados atingido. Não é possível adicionar.", "error");
                return;
            }

            const programDataForAPI = {
                nomePrograma: name,
                alimento: food,
                tempo: totalProgSeconds,
                potencia: power,
                charPonto: currentProgramBeingViewed?.char || FIXED_HEATING_CHAR,
                instrucoes: instructions,
                preDefinido: false
            };

            const method = isEditing ? 'PUT' : 'POST';
            const url = isEditing ? `${API_BASE_URL}/${editingId}` : API_BASE_URL;
            if (isEditing) {
                programDataForAPI.id = parseInt(editingId, 10);
            }
            const successMessage = isEditing ? `Programa "${name}" atualizado!` : `Programa "${name}" adicionado!`;

            try {
                const response = await fetch(url, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(programDataForAPI)
                });
                if (!response.ok) throw new Error(`Falha na operação: ${response.statusText}`);

                showMessage(successMessage, 'success');
                await fetchProgramsFromAPI();
                closeCustomProgramModal();

            } catch (error) {
                const userErrorMessage = (error.message.includes('Failed to fetch'))
                    ? "Erro de conexão ao salvar. Verifique se o servidor está rodando."
                    : `Erro ao salvar: ${error.message}`;
                showMessage(userErrorMessage, 'error');
            }
        });

        // --- DELETE Program (Only for custom) ---
        deleteProgramBtn.addEventListener('click', async () => {
            playBeep();
            if (!currentProgramBeingViewed || !currentProgramBeingViewed.isCustom) return;

            const { id, name } = currentProgramBeingViewed;

            if (!confirm(`Tem certeza que deseja excluir o programa customizado "${name}"?`)) return;
            try {
                const response = await fetch(`${API_BASE_URL}/${id}`, { method: 'DELETE' });
                if (!response.ok) throw new Error(`Falha ao excluir: ${response.statusText}`);
                showMessage(`Programa "${name}" excluído.`, 'success');
            } catch (error) {
                const userErrorMessage = (error.message.includes('Failed to fetch'))
                    ? "Erro de conexão ao excluir. Verifique se o servidor está rodando."
                    : `Erro ao excluir: ${error.message}`;
                showMessage(userErrorMessage, 'error');
            }
            console.log("oi")
            await fetchProgramsFromAPI();
            closeCustomProgramModal();
        });


        // --- Initial Application Setup ---
        async function initializeApp() {
            clearAll();
            await fetchProgramsFromAPI();
        }

        // Start the application
        initializeApp();

    </script>

</body>
</html>
